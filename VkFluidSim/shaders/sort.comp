// sort.comp
#version 450
// #extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_debug_printf : enable


layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// keys to sort
layout(std430, binding = 0) buffer KeyBuffer {
    uint keys[];
};
// values to sort with keys
layout(std430, binding = 1) buffer ValueBuffer {
    uint values[];
};

layout(push_constant) uniform PushConstants {
    uint elementCount;
    uint mergeSize;
    uint compareStride;
} pc;

void main() {
    uint index = gl_GlobalInvocationID.x;

    // Abort if we're out of bounds
    if (index >= pc.elementCount) {
        return;
    }

    // if (index == 0) {
    //     debugPrintfEXT("\n--- Unsorted Keys : Indices (sorted_keys : sorted_indices) ---\n");
    //     for (uint i = 0; i < pc.elementCount; i++) {
    //         debugPrintfEXT("  keys[%u] = %u, values[%u] = %u", i, keys[i], i, values[i]);
    //     }
    // }
    // Determine partner index
    uint partner_index = index ^ pc.compareStride;

    // The thread with the higher index is skipped to avoid double-swapping
    if (partner_index < index) {
        return;
    }

    // Determine the sort direction. This logic works with the new C++ loops
    // to correctly create and merge the bitonic sequences.
    bool ascending = ((index & pc.mergeSize) == 0);

    uint key1 = keys[index];
    uint key2 = keys[partner_index];

    // Compare and swap if necessary based on key order
    if ((key1 > key2) == ascending) {
        // Swap keys
        keys[index] = key2;
        keys[partner_index] = key1;

        // Swap values as well
        uint val1 = values[index];
        uint val2 = values[partner_index];
        values[index] = val2;
        values[partner_index] = val1;
    }
}


// void main() {
//     uint i = gl_GlobalInvocationID.x;
//     uint h = i & (pc.groupWidth - 1);
//     uint indexLow = h + (pc.groupHeight + 1) * (i / pc.groupWidth);
//     uint indexHigh = indexLow + (pc.stepIndex == 0 ? pc.groupHeight - 2 * h : (pc.groupHeight + 1) / 2);

//     if (indexHigh >= pc.count) return;

//     uint keyLow = keys[indexLow];
//     uint valueLow = values[indexLow];
//     uint keyHigh = keys[indexHigh];
//     uint valueHigh = values[indexHigh];

//     if (keyLow > keyHigh) {
//         keys[indexLow] = keyHigh;
//         keys[indexHigh] = keyLow;
//         values[indexLow] = valueHigh;
//         values[indexHigh] = valueLow;
//     }
// }

// void main() {
//     uint i = gl_GlobalInvocationID.x;
//     if (i >= pc.count) return;
    
//     uint inc = pc.groupWidth;
//     uint length = pc.groupHeight;
    
//     // Calculate which element this thread should handle
//     uint j = i ^ inc;
    
//     // Only process if this thread handles the smaller index
//     if (j > i && j < pc.count) {
//         uint keyI = keys[i];
//         uint keyJ = keys[j];
//         uint valueI = values[i];
//         uint valueJ = values[j];
        
//         // Determine sort direction
//         bool ascending = ((i & length) == 0);
        
//         // Swap if needed
//         if ((ascending && keyI > keyJ) || (!ascending && keyI < keyJ)) {
//             keys[i] = keyJ;
//             keys[j] = keyI;
//             values[i] = valueJ;
//             values[j] = valueI;
//         }
//     }
// }